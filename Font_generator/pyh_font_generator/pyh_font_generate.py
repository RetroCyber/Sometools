import io
import struct
import cv2
import numpy as np
import json
from print_font import PrintFont
from enum import Enum
from PIL import Image, ImageDraw, ImageFont
from dataclasses import dataclass
from typing import List

class FONT_LINE_SPACE(Enum):
    SPELL_FONT = 0x0215
    TALK_FONT = 0x0018
    TEXTURE_16_600 = 0x0210
    TEXTURE_24 = 0x0318
    CUSTOM = 0x64
class COLOR_CHANNEL(Enum):
    BLUE = 0
    GREEN = 1
    RED = 2
    ALPHA = 3

textture_16_600_charset = bytes([
    0x20, 0x00, 0x23, 0x00, 0x26, 0x00, 0x27, 0x00, 0x28, 0x00, 0x29, 0x00, 0x2C, 0x00, 0x2D, 0x00, 
    0x2E, 0x00, 0x2F, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 
    0x36, 0x00, 0x37, 0x00, 0x38, 0x00, 0x39, 0x00, 0x3A, 0x00, 0x40, 0x00, 0x41, 0x00, 0x42, 0x00, 
    0x43, 0x00, 0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00, 0x48, 0x00, 0x49, 0x00, 0x4A, 0x00, 
    0x4B, 0x00, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0x00, 0x4F, 0x00, 0x50, 0x00, 0x52, 0x00, 0x53, 0x00, 
    0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00, 0x58, 0x00, 0x59, 0x00, 0x5A, 0x00, 0x5C, 0x00, 
    0x5F, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x64, 0x00, 0x65, 0x00, 0x66, 0x00, 0x67, 0x00, 
    0x68, 0x00, 0x69, 0x00, 0x6A, 0x00, 0x6B, 0x00, 0x6C, 0x00, 0x6D, 0x00, 0x6E, 0x00, 0x6F, 0x00, 
    0x70, 0x00, 0x72, 0x00, 0x73, 0x00, 0x74, 0x00, 0x75, 0x00, 0x76, 0x00, 0x77, 0x00, 0x78, 0x00, 
    0x79, 0x00, 0x7A, 0x00, 0xA1, 0x00, 0x40, 0x81, 0x41, 0x81, 0x45, 0x81, 0x46, 0x81, 0x58, 0x81, 
    0x5B, 0x81, 0x60, 0x81, 0x69, 0x81, 0x6A, 0x81, 0xA1, 0x81, 0xA0, 0x82, 0xA2, 0x82, 0xA4, 0x82, 
    0xA6, 0x82, 0xA8, 0x82, 0xA9, 0x82, 0xAA, 0x82, 0xAB, 0x82, 0xAD, 0x82, 0xAF, 0x82, 0xB3, 0x82, 
    0xB5, 0x82, 0xB6, 0x82, 0xB7, 0x82, 0xB8, 0x82, 0xBD, 0x82, 0xBE, 0x82, 0xC1, 0x82, 0xC4, 0x82, 
    0xC5, 0x82, 0xC6, 0x82, 0xC7, 0x82, 0xC8, 0x82, 0xC9, 0x82, 0xCC, 0x82, 0xCD, 0x82, 0xCE, 0x82, 
    0xD2, 0x82, 0xD3, 0x82, 0xD4, 0x82, 0xD6, 0x82, 0xD9, 0x82, 0xDC, 0x82, 0xDD, 0x82, 0xDE, 0x82, 
    0xE0, 0x82, 0xE1, 0x82, 0xE2, 0x82, 0xE4, 0x82, 0xE8, 0x82, 0xE9, 0x82, 0xEB, 0x82, 0xED, 0x82, 
    0xF0, 0x82, 0xF1, 0x82, 0x41, 0x83, 0x42, 0x83, 0x43, 0x83, 0x45, 0x83, 0x46, 0x83, 0x47, 0x83, 
    0x48, 0x83, 0x49, 0x83, 0x4A, 0x83, 0x4C, 0x83, 0x4D, 0x83, 0x4E, 0x83, 0x4F, 0x83, 0x51, 0x83, 
    0x52, 0x83, 0x53, 0x83, 0x54, 0x83, 0x56, 0x83, 0x57, 0x83, 0x58, 0x83, 0x59, 0x83, 0x5A, 0x83, 
    0x5C, 0x83, 0x5E, 0x83, 0x62, 0x83, 0x63, 0x83, 0x65, 0x83, 0x66, 0x83, 0x67, 0x83, 0x68, 0x83, 
    0x69, 0x83, 0x6A, 0x83, 0x6C, 0x83, 0x6D, 0x83, 0x6E, 0x83, 0x6F, 0x83, 0x70, 0x83, 0x71, 0x83, 
    0x72, 0x83, 0x73, 0x83, 0x74, 0x83, 0x75, 0x83, 0x76, 0x83, 0x79, 0x83, 0x7B, 0x83, 0x7D, 0x83, 
    0x7E, 0x83, 0x80, 0x83, 0x81, 0x83, 0x82, 0x83, 0x83, 0x83, 0x84, 0x83, 0x85, 0x83, 0x87, 0x83, 
    0x89, 0x83, 0x8A, 0x83, 0x8B, 0x83, 0x8C, 0x83, 0x8D, 0x83, 0x8F, 0x83, 0x93, 0x83, 0xCB, 0x88, 
    0xD3, 0x88, 0xD9, 0x88, 0xDF, 0x88, 0xE4, 0x88, 0xEA, 0x88, 0xED, 0x88, 0xF1, 0x88, 0x5F, 0x89, 
    0x69, 0x89, 0x70, 0x89, 0x89, 0x89, 0x8C, 0x89, 0x8F, 0x89, 0x93, 0x89, 0x9D, 0x89, 0x9F, 0x89, 
    0xA1, 0x89, 0xA9, 0x89, 0xAD, 0x89, 0xAE, 0x89, 0xB3, 0x89, 0xB9, 0x89, 0xCA, 0x89, 0xCD, 0x89, 
    0xD4, 0x89, 0xD8, 0x89, 0xE8, 0x89, 0xEE, 0x89, 0xF1, 0x89, 0xF6, 0x89, 0x43, 0x8A, 0x45, 0x8A, 
    0x48, 0x8A, 0x4A, 0x8A, 0x79, 0x8A, 0x87, 0x8A, 0x8B, 0x8A, 0xB1, 0x8A, 0xB4, 0x8A, 0xC4, 0x8A, 
    0xCF, 0x8A, 0xD4, 0x8A, 0xD6, 0x8A, 0xDB, 0x8A, 0xDD, 0x8A, 0xE2, 0x8A, 0xEF, 0x8A, 0x40, 0x8B, 
    0x43, 0x8B, 0x4D, 0x8B, 0x50, 0x8B, 0x56, 0x8B, 0x5A, 0x8B, 0x5E, 0x8B, 0x74, 0x8B, 0x76, 0x8B, 
    0x85, 0x8B, 0x9E, 0x8B, 0xB3, 0x8B, 0xB6, 0x8B, 0xB7, 0x8B, 0xBD, 0x8B, 0xDF, 0x8B, 0xF3, 0x8B, 
    0x4F, 0x8C, 0x69, 0x8C, 0x71, 0x8C, 0x85, 0x8C, 0x88, 0x8C, 0x8E, 0x8C, 0xB2, 0x8C, 0xB4, 0x8C, 
    0xB6, 0x8C, 0xBA, 0x8C, 0xBB, 0x8C, 0xBE, 0x8C, 0xCF, 0x8C, 0xD6, 0x8C, 0xEA, 0x8C, 0xF5, 0x8C, 
    0xF8, 0x8C, 0x50, 0x8D, 0x58, 0x8D, 0x67, 0x8D, 0x72, 0x8D, 0x73, 0x8D, 0x7E, 0x8D, 0x80, 0x8D, 
    0x85, 0x8D, 0x87, 0x8D, 0x9C, 0x8D, 0xA1, 0x8D, 0xA8, 0x8D, 0xBF, 0x8D, 0xC4, 0x8D, 0xE7, 0x8D, 
    0xEC, 0x8D, 0xED, 0x8D, 0x4F, 0x8E, 0x51, 0x8E, 0x52, 0x8E, 0x55, 0x8E, 0x71, 0x8E, 0x74, 0x8E, 
    0x75, 0x8E, 0x78, 0x8E, 0x7D, 0x8E, 0x80, 0x8E, 0x8A, 0x8E, 0x8E, 0x8E, 0x9B, 0x8E, 0x9E, 0x8E, 
    0xA6, 0x8E, 0xB8, 0x8E, 0xED, 0x8E, 0x43, 0x8F, 0x47, 0x8F, 0x63, 0x8F, 0x70, 0x8F, 0x74, 0x8F, 
    0x8A, 0x8F, 0x97, 0x8F, 0x9C, 0x8F, 0xAA, 0x8F, 0xAC, 0x8F, 0xAD, 0x8F, 0xE0, 0x8F, 0xE3, 0x8F, 
    0xE9, 0x8F, 0xED, 0x8F, 0xEE, 0x8F, 0xF6, 0x8F, 0x46, 0x90, 0x53, 0x90, 0x56, 0x90, 0x58, 0x90, 
    0x5B, 0x90, 0x5E, 0x90, 0x5F, 0x90, 0x65, 0x90, 0x6A, 0x90, 0x6C, 0x90, 0x81, 0x90, 0x85, 0x90, 
    0x94, 0x90, 0xA2, 0x90, 0xA7, 0x90, 0xAF, 0x90, 0xB6, 0x90, 0xB9, 0x90, 0xCE, 0x90, 0xD3, 0x90, 
    0xD8, 0x90, 0xDD, 0x90, 0xE0, 0x90, 0xE1, 0x90, 0xE7, 0x90, 0xEC, 0x90, 0x44, 0x91, 0x49, 0x91, 
    0x73, 0x91, 0x7A, 0x91, 0x8A, 0x91, 0x93, 0x91, 0xAA, 0x91, 0xB0, 0x91, 0xB1, 0x91, 0xCC, 0x91, 
    0xD1, 0x91, 0xD6, 0x91, 0xE2, 0x91, 0xE3, 0x91, 0xE5, 0x91, 0xE9, 0x91, 0xF0, 0x91, 0xF2, 0x91, 
    0x4A, 0x92, 0x4B, 0x92, 0x63, 0x92, 0x66, 0x92, 0x6C, 0x92, 0x6D, 0x92, 0x6E, 0x92, 0x75, 0x92, 
    0x7C, 0x92, 0x83, 0x92, 0x98, 0x92, 0xB1, 0x92, 0xB4, 0x92, 0xB7, 0x92, 0xB8, 0x92, 0xB9, 0x92, 
    0xC3, 0x92, 0xE0, 0x92, 0xE8, 0x92, 0xEA, 0x92, 0x56, 0x93, 0x60, 0x93, 0x61, 0x93, 0x63, 0x93, 
    0x87, 0x93, 0x8A, 0x93, 0x8C, 0x93, 0x9D, 0x93, 0xAF, 0x93, 0xB5, 0x93, 0xB6, 0x93, 0xBF, 0x93, 
    0xC6, 0x93, 0xCD, 0x93, 0xD8, 0x93, 0xDF, 0x93, 0xF1, 0x93, 0xFA, 0x93, 0xFC, 0x93, 0x56, 0x94, 
    0x77, 0x94, 0x7A, 0x94, 0xC5, 0x94, 0xE9, 0x94, 0x5C, 0x95, 0x5F, 0x95, 0x62, 0x95, 0x73, 0x95, 
    0x83, 0x95, 0x90, 0x95, 0x91, 0x95, 0xCF, 0x95, 0xFB, 0x95, 0x44, 0x96, 0x53, 0x96, 0x5B, 0x96, 
    0x7B, 0x96, 0x80, 0x96, 0x9C, 0x96, 0xA2, 0x96, 0xB2, 0x96, 0xB3, 0x96, 0xBC, 0x96, 0xC5, 0x96, 
    0xDA, 0x96, 0xDF, 0x96, 0xE7, 0x96, 0xE9, 0x96, 0x49, 0x97, 0x4C, 0x97, 0x64, 0x97, 0x67, 0x97, 
    0x74, 0x97, 0x8E, 0x97, 0x9D, 0x97, 0xA2, 0x97, 0xAA, 0x97, 0xAC, 0x97, 0xB4, 0x97, 0xCD, 0x97, 
    0xCE, 0x97, 0xD1, 0x97, 0xEC, 0x97, 0xF1, 0x97, 0xF6, 0x97, 0xFB, 0x97, 0x40, 0x98, 0x41, 0x98, 
    0x4C, 0x98, 0x4F, 0x98, 0x56, 0x98, 0x5F, 0x98, 0x62, 0x98, 0x66, 0x98, 0x8B, 0x99, 0xDF, 0x9C, 
    0xD9, 0x9E, 0x4A, 0xE2, 0x59, 0xE3, 0x4B, 0xE5, 0x4E, 0xE5, 0x51, 0xE5, 0x72, 0xE7, 0x47, 0xE9, 
])

spell_font_charset = bytes([
    0x23, 0x00, 0x27, 0x00, 0x2C, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 
    0x35, 0x00, 0x37, 0x00, 0x38, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00, 0x44, 0x00, 0x46, 0x00, 
    0x49, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x61, 0x00, 0x63, 0x00, 0x64, 0x00, 0x65, 0x00, 0x66, 0x00, 
    0x69, 0x00, 0x6B, 0x00, 0x6C, 0x00, 0x6D, 0x00, 0x6E, 0x00, 0x70, 0x00, 0x73, 0x00, 0x74, 0x00, 
    0x75, 0x00, 0x79, 0x00, 0x40, 0x81, 0x41, 0x81, 0x45, 0x81, 0x48, 0x81, 0x49, 0x81, 0x5B, 0x81, 
    0x69, 0x81, 0x6A, 0x81, 0x75, 0x81, 0x76, 0x81, 0x83, 0x81, 0x84, 0x81, 0x95, 0x81, 0x96, 0x81, 
    0x4F, 0x82, 0x50, 0x82, 0x51, 0x82, 0x52, 0x82, 0x54, 0x82, 0x55, 0x82, 0x63, 0x82, 0x76, 0x82, 
    0xA0, 0x82, 0xA2, 0x82, 0xA4, 0x82, 0xA6, 0x82, 0xA8, 0x82, 0xA9, 0x82, 0xAA, 0x82, 0xAB, 0x82, 
    0xAD, 0x82, 0xAE, 0x82, 0xAF, 0x82, 0xB1, 0x82, 0xB2, 0x82, 0xB3, 0x82, 0xB5, 0x82, 0xB6, 0x82, 
    0xB7, 0x82, 0xB8, 0x82, 0xB9, 0x82, 0xBB, 0x82, 0xBC, 0x82, 0xBF, 0x82, 0xC1, 0x82, 0xC2, 0x82, 
    0xC4, 0x82, 0xC5, 0x82, 0xC6, 0x82, 0xC8, 0x82, 0xC9, 0x82, 0xCB, 0x82, 0xCC, 0x82, 0xCD, 0x82, 
    0xCE, 0x82, 0xCF, 0x82, 0xD1, 0x82, 0xD4, 0x82, 0xD6, 0x82, 0xD7, 0x82, 0xDC, 0x82, 0xDF, 0x82, 
    0xE0, 0x82, 0xE2, 0x82, 0xE6, 0x82, 0xE7, 0x82, 0xE8, 0x82, 0xE9, 0x82, 0xEA, 0x82, 0xEB, 0x82, 
    0xED, 0x82, 0xF0, 0x82, 0xF1, 0x82, 0x40, 0x83, 0x41, 0x83, 0x42, 0x83, 0x43, 0x83, 0x44, 0x83, 
    0x45, 0x83, 0x47, 0x83, 0x49, 0x83, 0x4A, 0x83, 0x4B, 0x83, 0x4C, 0x83, 0x4E, 0x83, 0x4F, 0x83, 
    0x52, 0x83, 0x53, 0x83, 0x54, 0x83, 0x55, 0x83, 0x56, 0x83, 0x57, 0x83, 0x58, 0x83, 0x59, 0x83, 
    0x5A, 0x83, 0x5B, 0x83, 0x5C, 0x83, 0x5E, 0x83, 0x5F, 0x83, 0x60, 0x83, 0x62, 0x83, 0x65, 0x83, 
    0x66, 0x83, 0x67, 0x83, 0x68, 0x83, 0x69, 0x83, 0x6A, 0x83, 0x6C, 0x83, 0x6E, 0x83, 0x6F, 0x83, 
    0x70, 0x83, 0x71, 0x83, 0x72, 0x83, 0x73, 0x83, 0x74, 0x83, 0x75, 0x83, 0x76, 0x83, 0x78, 0x83, 
    0x7A, 0x83, 0x7C, 0x83, 0x7D, 0x83, 0x7E, 0x83, 0x80, 0x83, 0x81, 0x83, 0x83, 0x83, 0x85, 0x83, 
    0x87, 0x83, 0x89, 0x83, 0x8A, 0x83, 0x8B, 0x83, 0x8C, 0x83, 0x8D, 0x83, 0x93, 0x83, 0x94, 0x83, 
    0xA3, 0x88, 0xA4, 0x88, 0xAB, 0x88, 0xAC, 0x88, 0xCB, 0x88, 0xD0, 0x88, 0xD9, 0x88, 0xE4, 0x88, 
    0xEA, 0x88, 0xEC, 0x88, 0xF3, 0x88, 0x41, 0x89, 0x46, 0x89, 0x4A, 0x89, 0x5E, 0x89, 0x5F, 0x89, 
    0x6B, 0x89, 0x7A, 0x89, 0x8A, 0x89, 0x8B, 0x89, 0x8E, 0x89, 0xA4, 0x89, 0xB3, 0x89, 0xBB, 0x89, 
    0xBD, 0x89, 0xC2, 0x89, 0xC6, 0x89, 0xCD, 0x89, 0xCE, 0x89, 0xD0, 0x89, 0xD4, 0x89, 0xDE, 0x89, 
    0xE4, 0x89, 0xF0, 0x89, 0xF5, 0x89, 0xF6, 0x89, 0xF7, 0x89, 0x45, 0x8A, 0x4A, 0x8A, 0x4D, 0x8A, 
    0x6F, 0x8A, 0x79, 0x8A, 0xA3, 0x8A, 0xA9, 0x8A, 0xAE, 0x8A, 0xB7, 0x8A, 0xD4, 0x8A, 0xD6, 0x8A, 
    0xE2, 0x8A, 0xEC, 0x8A, 0xF5, 0x8A, 0x40, 0x8B, 0x43, 0x8B, 0x49, 0x8B, 0x50, 0x8B, 0x53, 0x8B, 
    0x5A, 0x8B, 0x60, 0x8B, 0x90, 0x8B, 0xA5, 0x8B, 0xA8, 0x8B, 0xAB, 0x8B, 0xAD, 0x8B, 0xB6, 0x8B, 
    0xC7, 0x8B, 0xC9, 0x8B, 0xCA, 0x8B, 0xEC, 0x8B, 0xEF, 0x8B, 0xF3, 0x8B, 0x4E, 0x8C, 0x82, 0x8C, 
    0x84, 0x8C, 0x88, 0x8C, 0x8E, 0x8C, 0x97, 0x8C, 0x98, 0x8C, 0x9D, 0x8C, 0xA9, 0x8C, 0xB6, 0x8C, 
    0xBB, 0x8C, 0xC0, 0x8C, 0xC3, 0x8C, 0xC4, 0x8C, 0xC5, 0x8C, 0xCE, 0x8C, 0xDC, 0x8C, 0xF0, 0x8C, 
    0xF5, 0x8C, 0xF6, 0x8C, 0x4B, 0x8D, 0x73, 0x8D, 0x7E, 0x8D, 0x8B, 0x8D, 0x91, 0x8D, 0x95, 0x8D, 
    0xA1, 0x8D, 0xA3, 0x8D, 0xAE, 0x8D, 0xB0, 0x8D, 0xB2, 0x8D, 0xB7, 0x8D, 0xBF, 0x8D, 0xC5, 0x8D, 
    0xD9, 0x8D, 0xDA, 0x8D, 0xE0, 0x8D, 0x44, 0x8E, 0x45, 0x8E, 0x4D, 0x8E, 0x4F, 0x8E, 0x52, 0x8E, 
    0x55, 0x8E, 0x61, 0x8E, 0x6D, 0x8E, 0x71, 0x8E, 0x74, 0x8E, 0x80, 0x8E, 0x8B, 0x8E, 0xA9, 0x8E, 
    0xAE, 0x8E, 0xBD, 0x8E, 0xC0, 0x8E, 0xD4, 0x8E, 0xDF, 0x8E, 0xE5, 0x8E, 0xE8, 0x8E, 0xEA, 0x8E, 
    0xF4, 0x8E, 0x4D, 0x8F, 0x52, 0x8F, 0x65, 0x8F, 0x6F, 0x8F, 0x70, 0x8F, 0x88, 0x8F, 0x97, 0x8F, 
    0xAC, 0x8F, 0xB6, 0x8F, 0xB8, 0x8F, 0xC1, 0x8F, 0xE3, 0x8F, 0x46, 0x90, 0x53, 0x90, 0x55, 0x90, 
    0x5E, 0x90, 0x5F, 0x90, 0x6A, 0x90, 0x6B, 0x90, 0x6C, 0x90, 0x73, 0x90, 0x77, 0x90, 0x85, 0x90, 
    0x94, 0x90, 0xA1, 0x90, 0xA2, 0x90, 0xA7, 0x90, 0xAF, 0x90, 0xB0, 0x90, 0xB3, 0x90, 0xB9, 0x90, 
    0xCE, 0x90, 0xCF, 0x90, 0xE0, 0x90, 0xE2, 0x90, 0xE5, 0x90, 0xE6, 0x90, 0xE7, 0x90, 0xED, 0x90, 
    0xF9, 0x90, 0xFC, 0x90, 0x49, 0x91, 0x4D, 0x91, 0x4F, 0x91, 0x50, 0x91, 0x53, 0x91, 0x63, 0x91, 
    0x6D, 0x91, 0x70, 0x91, 0x7A, 0x91, 0x88, 0x91, 0x96, 0x91, 0x9C, 0x91, 0xA2, 0x91, 0xAB, 0x91, 
    0xBE, 0x91, 0xCC, 0x91, 0xE5, 0x91, 0xE9, 0x91, 0x44, 0x92, 0x65, 0x92, 0x6E, 0x92, 0x75, 0x92, 
    0x86, 0x92, 0x88, 0x92, 0x8D, 0x92, 0xA6, 0x92, 0xB4, 0x92, 0xB5, 0x92, 0xB9, 0x92, 0xBC, 0x92, 
    0xC4, 0x92, 0xC6, 0x92, 0xC7, 0x92, 0xDE, 0x92, 0xEA, 0x92, 0x47, 0x93, 0x54, 0x93, 0x56, 0x93, 
    0x60, 0x93, 0x64, 0x93, 0x78, 0x93, 0x7B, 0x93, 0x83, 0x93, 0x8D, 0x93, 0x92, 0x93, 0xA6, 0x93, 
    0xB1, 0x93, 0xB9, 0x93, 0xBD, 0x93, 0xBF, 0x93, 0xC1, 0x93, 0xF1, 0x93, 0xF2, 0x93, 0xFA, 0x93, 
    0xFC, 0x93, 0x40, 0x94, 0x4D, 0x94, 0x4F, 0x94, 0x52, 0x94, 0x5C, 0x94, 0x67, 0x94, 0x6A, 0x94, 
    0x70, 0x94, 0x8D, 0x94, 0x9A, 0x94, 0xAA, 0x94, 0xAD, 0x94, 0xB1, 0x94, 0xBB, 0x94, 0xD1, 0x94, 
    0xD6, 0x94, 0xE6, 0x94, 0xE9, 0x94, 0xEF, 0x94, 0xF2, 0x94, 0x53, 0x95, 0x59, 0x95, 0x5C, 0x95, 
    0x6E, 0x95, 0x73, 0x95, 0x84, 0x95, 0x91, 0x95, 0x95, 0x95, 0x97, 0x95, 0x9F, 0x95, 0xA7, 0x95, 
    0xA8, 0x95, 0xAA, 0x95, 0xBD, 0x95, 0xBE, 0x95, 0xCA, 0x95, 0xCF, 0x95, 0xEF, 0x95, 0xF3, 0x95, 
    0xFA, 0x95, 0xFB, 0x95, 0x40, 0x96, 0x41, 0x96, 0x52, 0x96, 0x5D, 0x96, 0x6C, 0x96, 0x7B, 0x96, 
    0x82, 0x96, 0x87, 0x96, 0x8B, 0x96, 0xA7, 0x96, 0xB1, 0x96, 0xB2, 0x96, 0xB3, 0x96, 0xB4, 0x96, 
    0xBC, 0x96, 0xBD, 0x96, 0xC5, 0x96, 0xCA, 0x96, 0xD1, 0x96, 0xDA, 0x96, 0xE5, 0x96, 0xEC, 0x96, 
    0x4A, 0x97, 0x64, 0x97, 0x6C, 0x97, 0x72, 0x97, 0x74, 0x97, 0x76, 0x97, 0x79, 0x97, 0x7A, 0x97, 
    0x7D, 0x97, 0x88, 0x97, 0x8B, 0x97, 0x8E, 0x97, 0x90, 0x97, 0x92, 0x97, 0x95, 0x97, 0xAC, 0x97, 
    0xAF, 0x97, 0xB4, 0x97, 0xB5, 0x97, 0xBC, 0x97, 0xC7, 0x97, 0xCD, 0x97, 0xCE, 0x97, 0xD6, 0x97, 
    0xEC, 0x97, 0xED, 0x97, 0xF6, 0x97, 0x43, 0x98, 0x52, 0x98, 0x53, 0x98, 0x54, 0x98, 0x62, 0x98, 
    0x6F, 0x98, 0x72, 0x98, 0xCC, 0x99, 0xDE, 0x9B, 0x61, 0x9C, 0xDF, 0x9C, 0xF0, 0x9C, 0xB1, 0x9D, 
    0x4F, 0x9E, 0x58, 0x9E, 0xF2, 0x9E, 0x54, 0x9F, 0xC9, 0xE1, 0x49, 0xE2, 0x59, 0xE3, 0xC4, 0xE3, 
    0xBF, 0xE4, 0xBB, 0xE8, 
])

# 定义字符详情数据结构
@dataclass
class CharaDetail:
    x: int  # 字符在整张图像中的x坐标
    y: int  # 字符在整张图像中的y坐标
    x_width: int  # 字符x方向宽度
    y_width: int  # 字符y方向宽度
    align_offset: int  # 基线对齐偏移量
    color: int  # 存储颜色通道 (0: BLUE, 1: GREEN, 2: RED, 3: ALPHA)

    def is_character_supported(self, character):
        """
        检测单个字符是否被字体支持。
        
        参数：
        - character: 要检测的字符（单个字符）
        
        返回值：
        - True: 如果字体支持该字符
        - False: 如果字体不支持该字符
        """
        return ord(character) in self.character_map

    def are_characters_supported(self, characters):
        """
        检测多个字符是否被字体支持。
        
        参数：
        - characters: 要检测的字符列表或字符串
        
        返回值：
        - 一个字典，键为字符，值为 True/False，表示是否支持
        """
        return {char: self.is_character_supported(char) for char in characters}

# 从指定文件中提取字符集
def read_spell_chars(fn):
    try:
        # 读取 JSON 文件
        with open(fn, 'r', encoding='utf-8') as file:
            data = json.load(file)

        # 提取所有的 value 并生成字符集合
        char_set = set()
        for value in data.values():
            char_set.update(value)

        # 按 GBK 编码值对字符进行排序
        sorted_chars = sorted(char_set, key=lambda char: char.encode('gbk'))

        # 输出结果
        return sorted_chars

    except FileNotFoundError:
        print(f"文件 {fn} 未找到，请检查文件路径。")
    except json.JSONDecodeError:
        print(f"文件 {fn} 不是有效的 JSON 格式。")
    except Exception as e:
        print(f"发生错误：{e}")


def read_csv_chars(fn):
    # 打开并读取 JSON 文件
    with open(fn, 'r', encoding='utf-8') as file:
        data = json.load(file)

    # 提取所有的 value
    char_set = set()
    for key, value_dict in data.items():
        if key != "_":  # 跳过键为 "_" 的内容
            for inner_key, inner_value in value_dict.items():
                if isinstance(inner_value, str):  # 确保 value 是字符串
                    char_set.update(inner_value)  # 将字符串中的每个字符加入集合

    # 将字符集合按照 GBK 编码排序
    sorted_chars = sorted(char_set, key=lambda x: x.encode('gbk'))

    return sorted_chars

# 为文字添加外发光效果
def draw_glowing_text(image_size, char, font, 
                      text_position, text_color=255, glow_color=150, 
                      glow_radius=2, blur_radius=2):
    # 创建灰度图像
    temp_img = Image.new("L", image_size, 0)
    draw = ImageDraw.Draw(temp_img)
    
    # 绘制文字
    draw.text(text_position, char, font=font, fill=text_color)
    
    # 转换为NumPy数组以便处理
    image_np = np.array(temp_img)
    
    # 创建扩散效果
    glow_layer = np.zeros_like(image_np)
    for r in range(1, glow_radius + 1):
        layer = Image.new("L", image_size, 0)
        layer_draw = ImageDraw.Draw(layer)
        layer_draw.text(text_position, char, font=font, fill=glow_color)
        layer_np = np.array(layer)
        
        # 用OpenCV膨胀生成扩散效果
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (r * 2 + 1, r * 2 + 1))
        dilated = cv2.dilate(layer_np, kernel)
        
        # 叠加扩散效果
        glow_layer = np.maximum(glow_layer, dilated)
    
    # 将文字从扩散层中扣除，确保文字部分不被模糊
    glow_layer = np.where(image_np == text_color, 0, glow_layer)
    
    # 对扩散层的最外围进行高斯模糊
    blurred_glow = cv2.GaussianBlur(glow_layer, (blur_radius * 2 + 1, blur_radius * 2 + 1), 0)
    
    # 合并文字和模糊后的扩散效果
    final_np = np.maximum(image_np, blurred_glow)
    
    # 转换为Pillow图像
    final_image = Image.fromarray(final_np)
    
    return final_image

# Load the font file
def load_font(font_path, font_size):
    return ImageFont.truetype(font_path, font_size)

# 将枚举成员转换为小端序字节
def enum_member_to_little_endian_byte(enum) -> bytes:
    return struct.pack('<H', enum.value)

def generate_halfwidth_chars():
    """
    生成所有半角字符的字符列表，包括标点符号、数字、大写字母、小写字母。

    :return: 半角字符列表
    """
    # 半角字符的 ASCII 范围
    ascii_ranges = [
        range(0x20, 0x7E + 1)  # 半角字符的 ASCII 范围：从 0x21 到 0x7E
    ]
    
    # 生成字符列表
    halfwidth_characters = [chr(code_point) for r in ascii_ranges for code_point in r]
    
    return halfwidth_characters

# Generate GB2312 character set
def generate_gb2312_chars():
    gb2312_chars = []
    # GB2312 高字节和低字节范围
    for high in range(0xA1, 0xFE + 1):  # 高字节范围
        for low in range(0xA1, 0xFE + 1):  # 低字节范围
            try:
                # 拼接成字节，并解码为 GB2312 字符
                byte_seq = bytes([high, low])
                char = byte_seq.decode('gb2312')
                gb2312_chars.append(char)
            except UnicodeDecodeError:
                # 如果不是有效字符，跳过
                continue
    return gb2312_chars

def generate_big5_chars():
    big5_chars = []
    # 遍历 Big5 的第一个字节范围
    for high_byte in range(0x81, 0xFE + 1):
        # 遍历 Big5 的第二个字节范围
        for low_byte in range(0x40, 0x7E + 1):  # 0x40 到 0x7E
            try:
                char = bytes([high_byte, low_byte]).decode('big5')
                big5_chars.append(char)
            except UnicodeDecodeError:
                pass  # 非法编码跳过
        for low_byte in range(0xA1, 0xFE + 1):  # 0xA1 到 0xFE
            try:
                char = bytes([high_byte, low_byte]).decode('big5')
                big5_chars.append(char)
            except UnicodeDecodeError:
                pass  # 非法编码跳过
    return big5_chars

def generate_shift_jis_chars():
    """
    生成所有合法的Shift-JIS编码字符。
    返回一个包含所有字符的列表。
    """
    all_chars = []
    for byte1 in range(0x20, 0xFF):  # 遍历第一个字节
        try:
            char = bytes([byte1]).decode('shift_jis')
            all_chars.append(char)
        except UnicodeDecodeError:
            pass  # 非法的单字节字符，跳过

    for byte1 in range(0x81, 0xA0):  # 遍历双字节字符范围
        for byte2 in range(0x40, 0xFF):
            try:
                char = bytes([byte1, byte2]).decode('shift_jis')
                all_chars.append(char)
            except UnicodeDecodeError:
                pass  # 非法的双字节字符，跳过

    for byte1 in range(0xE0, 0xFF):  # 遍历双字节字符的另一部分范围
        for byte2 in range(0x40, 0xFF):
            try:
                char = bytes([byte1, byte2]).decode('shift_jis')
                all_chars.append(char)
            except UnicodeDecodeError:
                pass  # 非法的双字节字符，跳过

    return all_chars

def is_chinese_char(char):
    if '\u4e00' <= char <= '\u9fff':
        return True
    return False

def bytes_to_chars(byte_data):
    # 确保输入是字节类型
    if not isinstance(byte_data, bytes):
        raise ValueError("Input must be of type 'bytes'")
    
    # 初始化结果列表
    lc = []
    
    # 遍历字节数据，每2字节处理一次
    for i in range(0, len(byte_data), 2):
        # 取出2字节（Shift_JIS小端序）
        two_bytes = byte_data[i:i+2]
        # 转换为大端序（因为Shift_JIS通常使用大端序）
        big_endian_bytes = two_bytes[::-1]
        # 将2字节解码为字符
        try:
            char = big_endian_bytes.decode('shift_jis')
            lc.append(char)
        except UnicodeDecodeError:
            # 如果解码失败，可以选择跳过或记录错误
            lc.append(None)  # 或者其他占位符
    
    return lc

def draw_talkfont_char(draw_obj, char, font, x, y, rotate, char_size, cut_offset=0):
    """Helper function to draw a character with optional rotation."""
    img_width, img_height = char_size
    if rotate:
        # Create a separate image for the character to apply rotation
        temp_img = Image.new('L', (img_width, img_height), 0)
        temp_draw = ImageDraw.Draw(temp_img)
        text_bbox = temp_draw.textbbox((0, 0), char, font=font)
        # Make the characters fit tightly to the right border
        char_x = img_width - text_bbox[2]
        temp_draw.text((char_x, 0), char, font=font, fill=255)
        rotated_img = temp_img.rotate(90, expand=True)
        # Paste rotated character into the main draw object
        draw_obj.bitmap((x - cut_offset, y), rotated_img, fill=255)
    else:
        # Draw character directly without rotation
        temp_img = Image.new('L', (img_width, img_height), 0)
        temp_draw = ImageDraw.Draw(temp_img)
        text_bbox = temp_draw.textbbox((0, 0), char, font=font)
        temp_draw.text((0, 0), char, font=font, fill=255)
        cropped = temp_img.crop(text_bbox)
        temp_draw.rectangle(text_bbox, fill=0)
        temp_img.paste(cropped, (0, 0))
        draw_obj.bitmap((x, y), temp_img, fill=255)

def convert_to_gb2312(char_list):
    """
    将字符列表中的数据全部转换为 GB2312 编码，并返回字节流。
    
    :param char_list: List[str] - 包含字符串数据的列表
    :return: bytes - 转换后的 GB2312 编码字节流
    """
    if not isinstance(char_list, list):
        raise ValueError("输入必须是一个字符列表")
    
    try:
        # 将字符列表中的每个字符串转换为 GB2312 编码并拼接到字节流
        gb2312_bytes = b''.join([
    # 如果编码结果长度为 1 字节，补足为 2 字节并调整为小端序
        (b'\x00' + char.encode('gb2312'))[::-1] if len(char.encode('gb2312')) == 1
        else char.encode('gb2312')[::-1]  # 直接反转字节序
        for char in char_list
    ])
        return gb2312_bytes
    except UnicodeEncodeError as e:
        raise ValueError(f"字符列表中包含无法用 GB2312 编码表示的字符: {e}")

def convert_to_shift_jis(char_list):
    """
    将字符列表编码为Shift-JIS字节流，并将每个字符的字节码表示为两字节小端序。
    :param char_list: 包含Unicode字符的列表
    :return: 合并后的字节流
    """
    byte_stream = b''
    for char in char_list:
        try:
            # 使用 Shift-JIS 对字符进行编码
            encoded_bytes = char.encode('shift_jis')
            
            if len(encoded_bytes) == 1:  # 单字节字符
                # 单字节字符补 0x00 在高位，确保为两字节小端序
                byte_stream += encoded_bytes + b'\x00'
            elif len(encoded_bytes) == 2:  # 双字节字符
                # 确保小端序存储（字节顺序交换）
                byte_stream += encoded_bytes[1:2] + encoded_bytes[0:1]
            else:
                raise ValueError(f"字符 '{char}' 编码结果长度异常")
        except UnicodeEncodeError:
            raise ValueError(f"字符 '{char}' 无法编码为Shift-JIS")
    return byte_stream

def convert_to_ucs_2le(lc):
    if not isinstance(lc, list):
        raise ValueError("输入必须是一个字符列表")
    
    try:
        # 将字符列表中的每个字符串转换为 UCS-2LE 编码并拼接到字节流
        ucs_2le_bytes = b''.join([char.encode('utf-16le') for char in lc])
        return ucs_2le_bytes
    except UnicodeEncodeError as e:
        raise ValueError(f"字符列表中包含无法用UCS-2LE 编码表示的字符: {e}")

# Create a grid of characters with RGBA channels
def create_character_grid(lf, chars, image_size=(2048, None), 
                          char_offset=2, extra_height=8,
                          left_cut=0, char_size=(32, 32),
                          non_rotatable=[], align_table={}, 
                          custom_char_list={}, talkfont=False):
    # Fixed width of the image
    canvas_size = char_size
    cut = 0
    fixed_width = image_size[0]
    char_width = canvas_size[0]
    min_font = min(lf, key=lambda font: font.cut_offset)
    min_cut = min_font.cut_offset
    img_height = canvas_size[1] + char_offset - min_cut

    # Initialize variables for the final image
    final_height = 0
    final_img = None
    chara_info: List[CharaDetail] = []  # Save char info

    i = 0
    while i < len(chars):
        # Create new images for each channel (R, G, B, A) for one row of characters
        r_img = Image.new('L', (fixed_width, img_height), 0)  # Red channel
        g_img = Image.new('L', (fixed_width, img_height), 0)  # Green channel
        b_img = Image.new('L', (fixed_width, img_height), 0)  # Blue channel
        a_img = Image.new('L', (fixed_width, img_height), 0)  # Alpha channel

        # Create draw objects for each channel
        r_draw = ImageDraw.Draw(r_img)
        g_draw = ImageDraw.Draw(g_img)
        b_draw = ImageDraw.Draw(b_img)
        a_draw = ImageDraw.Draw(a_img)

        # Track current x position in the row
        x = 0
        font = None
        color_cnt = 0
        while i < len(chars):
            y = 0

            # Check if there's enough space for a new character
            if fixed_width - x < char_width:
                # Not enough space, end this row and move to the next row
                break

            # Check if this font have this char.
            draw_font = lf[0]                           # Set the first font as defult
            for index in lf:
                if (chars[i] in index.char_table):
                    draw_font = index
                    break
            
            # Get font data.
            font = draw_font.font_object
            cut = draw_font.cut_offset
            align_offset = draw_font.align_offset

            # Determine whether the current character should be rotated
            rotate = talkfont and (chars[i] not in non_rotatable)

            # Determine the color channel for the current character
            color_channel = color_cnt
            color_enum = COLOR_CHANNEL(color_channel)

            # Draw each character on its respective channel
            draw_func = None
            if color_enum == COLOR_CHANNEL.BLUE:
                draw_func = b_draw
            elif color_enum == COLOR_CHANNEL.GREEN:
                draw_func = g_draw
            elif color_enum == COLOR_CHANNEL.RED:
                draw_func = r_draw
            elif color_enum == COLOR_CHANNEL.ALPHA:
                draw_func = a_draw

            if (chars[i] == ' ' or chars[i] == '　'):
                space_bbox = draw_func.textbbox((0, 0), chars[i], font=font)
                chara_info.append(CharaDetail(
                x = 0,
                y = 0,  # 当前字符所在行的起始y坐标
                x_width = space_bbox[2],
                y_width = 0,
                align_offset = 0,
                color = color_channel  # 当前字符存储的颜色通道
                ))
                i += 1
                continue

            # Draw the character
            actual_size = None
            if (talkfont):
                draw_talkfont_char(draw_func, chars[i], font, x, 1, rotate, (canvas_size[0] + 5,canvas_size[1] + 5), cut_offset=cut)
                actual_size = draw_func.textbbox((0, 0), chars[i], font=font)       # 实际宽高
            else:
                char_img = draw_glowing_text(canvas_size, chars[i], font, 
                                             text_position=(2, 2),
                                            #  glow_radius=2,         # Texture24
                                            #  blur_radius=3
                                             glow_radius=1,
                                             blur_radius=2
                                             )
                actual_size = char_img.getbbox()        # 获取图像真实位置
                if not actual_size:
                    actual_size = draw_func.textbbox((0, 0), chars[i], font=font)
                draw_func.bitmap((x - actual_size[0], 1 - actual_size[1]), char_img, fill=255)

            text_width = actual_size[2] - actual_size[0]
            text_height = actual_size[3] - actual_size[1]

            # 生成字符渲染数据
            y_width = 0
            x_width = 0
            align = 0
            if (talkfont and chars[i] in non_rotatable):
                x_width = text_width
                y_width = text_height

            else:
                if (talkfont):
                    x_width = actual_size[3] - cut
                    y_width = text_width
                else:
                    x_width = actual_size[2]
                    y_width = text_height

            # 计算字符对齐偏移
            if (talkfont):
                if (chars[i] in non_rotatable):
                    align = actual_size[3] - text_height - cut
                else:
                    align = canvas_size[1] - y_width
            else:
                align = actual_size[1]

            if (align < 0):
                align = 0

            if (chars[i] in align_table.keys()):
                align = align_table[chars[i]]
            align += align_offset

            left_offset = top_offset = right_offfset = bottom_offset = 0
            if (chars[i] in custom_char_list.keys()):
                left_offset, top_offset, right_offfset, bottom_offset = custom_char_list[chars[i]]

            # Record character details
            chara_info.append(CharaDetail(
                x = x + left_offset,
                y = y + final_height + top_offset,  # 当前字符所在行的起始y坐标
                x_width = x_width + right_offfset,
                y_width = y_width + 1 + bottom_offset, 
                align_offset = align,
                color = color_channel  # 当前字符存储的颜色通道
            ))

            # Move x position only after all 4 channels are written
            color_cnt += 1
            if color_enum == COLOR_CHANNEL.ALPHA:
                x += char_width + char_offset - cut - left_cut
                color_cnt = 0

            i += 1

        # Merge the channels into a single RGBA image for this row
        row_img = Image.merge('RGBA', (r_img, g_img, b_img, a_img))

        # Append this row to the final image
        if final_img is None:
            final_img = row_img
        else:
            # Create a new image with extended height
            new_height = final_height + img_height
            temp_img = Image.new('RGBA', (fixed_width, new_height))
            temp_img.paste(final_img, (0, 0))
            temp_img.paste(row_img, (0, final_height))
            final_img = temp_img

        # Update final height
        final_height += img_height

    # Add extra height to the final image
    final_height += extra_height
    extended_img = Image.new('RGBA', (fixed_width, final_height), (0, 0, 0, 0))
    extended_img.paste(final_img, (0, 0))

    # 将字符信息转换为字节流
    chara_info_bytes = chara_info_to_bytes(chara_info)

    return extended_img, chara_info_bytes

# 将字符信息列表转换为字节流，并以小端序排列。
def chara_info_to_bytes(chara_info: List[CharaDetail]) -> bytes:
    byte_stream = b""
    for char in chara_info:
        # 使用 struct 打包数据为字节流
        # 格式 '<hhBBBB' 表示小端序，两个 int16，四个 uint8
        byte_stream += struct.pack(
            '<hhBBBB',  # 小端序（<），两个 int16 (h)，四个 uint8 (B)
            char.x,     # x 坐标
            char.y,     # y 坐标
            char.x_width, # 图像宽度
            char.y_width, # 图像高度
            char.align_offset, # y 偏移
            char.color  # 颜色通道
        )
    return byte_stream

def main():
    # Load font list
    lf = [
        # PrintFont("TaipeiSansTCBeta-Regular.ttf", 24, 0, 0)     #talkfont(zh-hant)
        # PrintFont("siyuanheitiCNMedium.ttf", 24, 6, 0)        #talkfont(zh-hans)
        # PrintFont("cangeyayueti.ttf", 25, 0, 6),              #texture24(zh-hans)
        # PrintFont("A-OTF-FolkPro-Heavy.otf", 23, 0, 6),
        # PrintFont("尔雅静思黑.ttf", 25, 0, 0)
        # PrintFont("cangeyayueti.ttf", 14, 0, 3),              #texture16(zh-hans)
        # PrintFont("A-OTF-FolkPro-Heavy.otf", 12, 0, 3),
        # PrintFont("尔雅静思黑.ttf", 14, 0, 0)
        # PrintFont("download.ttf", 23, 0, 0)                     #spell_font(zh-hans)
        PrintFont("msyh_2.ttf", 22, 0, 0)
    ]

    # Generate GB2312 characters
    gb2312_characters = generate_gb2312_chars()
    halfwidth_characters = generate_halfwidth_chars()
    shift_jis_chars = generate_shift_jis_chars()
    big5_chars = generate_big5_chars()

    # lc = halfwidth_characters + ['·', '｡', '—', '⁇', '⁈', '⁉', '‼'] + gb2312_characters + ['猯', '啰']
    extra_chars = ['猯', '語', '鯛', '鷹', '団', '鹸', '論', '観', '測', '夢', '紅', '蒼', '長', '東', '薫', '維', '阇', '鰯', '鳥', '島', '貴']
    lc = halfwidth_characters + ['＆', '｡', '—', 'ー', '⁇', '⁈', '⁉', '‼'] + gb2312_characters + extra_chars
    lb5c = halfwidth_characters + ['～'] + big5_chars
    lsp = read_spell_chars("spells.js")
    lhc = read_csv_chars("item.csv.jdiff")


    talk_font = False

    non_rotation = ['…', '—', '（', '）', '“', '”', '《', '》', '【', '】', '『', '』', '「', '」', '～']

    # talkfont(zh-hans)
    # manually_align_adjust = {
    #     '…': 10,
    #     '·': 6,
    #     # '！': 0,
    #     # '？': 0
    #     '，': 0,
    #     '。': 0,
    #     '—': 10,
    #     '“': 0,
    #     '”': 0,
    #     '⁇': 0,
    #     '⁈': 3,
    #     '⁉': 3,
    #     '‼': 5,
    #     '、': 0
    # }

    # for i in lc:
    #     if (is_chinese_char(i)):
    #         manually_align_adjust[i] = 0

    # custom_char_list = {
    #     '！':(0, 14, 0, -14),
    #     '？':(0, 13, 0, -13),
    #     '，':(12, 12, -12, -12),
    #     '。':(12, 13, -12, -11),
    #     '“':(12, 0, -12, -12),
    #     '”':(0, 0, -12, -12),
    #     '、':(12, 12, -12, -12),
    #     '·':(2, 0, -2, 0)
    # }

    # texture_24_600(zh-hans)
    # custom_texture_24 = {}
    # for i in lc:
    #     custom_texture_24[i] = (2, 0, -2, 0)
    # custom_texture_24['（'] = (2, 0, -12, 0)
    # custom_texture_24['狭'] = (3, 0, -3, 0)
    # custom_texture_24['的'] = (1, 0, -1, 0)
    # custom_texture_24['相'] = (2, 0, 1, 0)
    # custom_texture_24['吹'] = (0, 0, 0, -1)
    # align_texture_24 = {
    #     '气': 1
    # }

    # spell_font(zh-hans)
    # custom_spell = {
    #     "「":(0, 0, -8, 0),
    #     "＊":(-6, 0, 6, 0),
    #     "！":(-8, 0, 10, 0)
    # }

    non_rotation = non_rotation + halfwidth_characters

    # Create character grid
    # chars_data = bytes_to_chars(textture_16_600_charset)
    img, chara_info = create_character_grid(lf, lsp, char_offset=2, 
                                            extra_height=10, non_rotatable=non_rotation, 
                                            # left_cut=4,                   # texture_24_600(zh-hans)
                                            # char_size=(35, 35), 
                                            char_size=(32, 32),           # spell_font(zh-hans)
                                            left_cut=2, 
                                            # char_size=(22, 22), 
                                            # align_table=manually_align_adjust,    # talk_font(zh-hans)
                                            # custom_char_list=custom_char_list,
                                            # align_table=align_texture_24,     # texture_24(zh-hans)
                                            # custom_char_list=custom_texture_24, 
                                            # custom_char_list=custom_spell, 
                                            talkfont=talk_font)

    # Save the image

    with io.BytesIO() as b:
        img.save(b, format='BMP')
        img_buff = b.getvalue()

    line_space = enum_member_to_little_endian_byte(FONT_LINE_SPACE.TALK_FONT)
    # chara_num = len(lc).to_bytes(2, byteorder='little')           # texture24
    chara_num = len(lsp).to_bytes(2, byteorder='little')            # spell_font
    # chara_num = len(lsc).to_bytes(2, byteorder='little')
    # chara_num = len(chars_data).to_bytes(2, byteorder='little')

    # font_data = img_buff + line_space + chara_num + convert_to_ucs_2le(lc) + chara_info       # texture24
    # font_data = img_buff + line_space + chara_num + convert_to_ucs_2le(lsp) + chara_info        # spell_font
    font_data = img_buff + line_space + chara_num + convert_to_ucs_2le(lsp) + chara_info        # texture16
    # font_data = img_buff + line_space + chara_num + textture_16_600_charset + chara_info

    with open('spell_font.bmp', 'wb') as f:
        f.write(font_data)

if __name__ == "__main__":
    main()